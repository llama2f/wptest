{"version":3,"sources":["webpack://wptest/./src/js/browser.js","webpack://wptest/./src/js/deSVG.js","webpack://wptest/./src/js/gotop.js","webpack://wptest/./src/js/header_menu.js","webpack://wptest/./src/js/menu_openclose.js","webpack://wptest/./src/js/onTouch.js","webpack://wptest/./src/js/stickyfill.js","webpack://wptest/./node_modules/desvg/desvg.js","webpack://wptest/./node_modules/intersection-observer/intersection-observer.js","webpack://wptest/webpack/bootstrap","webpack://wptest/webpack/runtime/compat get default export","webpack://wptest/webpack/runtime/define property getters","webpack://wptest/webpack/runtime/hasOwnProperty shorthand","webpack://wptest/webpack/runtime/make namespace object","webpack://wptest/./src/index.js"],"names":["userAgent","window","navigator","toLowerCase","console","log","tag","document","getElementsByTagName","indexOf","classList","add","addEventListener","deSVG","el","getElementById","header","pageYOffset","setAttribute","remove","gotop","scrollTo","top","behavior","headerNav","nav_btn","nav_list","getAttribute","readyState","menu","querySelectorAll","toggle","content","nextElementSibling","i","length","passive","seppuku","isWindowDefined","getComputedStyle","testNode","createElement","some","prefix","style","position","e","isInitialized","shadowRootExists","ShadowRoot","scroll","left","stickies","extend","targetObj","sourceObject","key","hasOwnProperty","parseNumeric","val","parseFloat","getDocOffsetTop","node","docOffsetTop","offsetTop","offsetParent","Sticky","HTMLElement","Error","sticky","_node","_stickyMode","_active","push","refresh","_removed","_deactivate","nodeComputedStyle","nodeComputedProps","display","marginTop","marginBottom","marginLeft","marginRight","cssFloat","isNaN","originalPosition","referenceNode","parentNode","host","nodeWinOffset","getBoundingClientRect","parentWinOffset","parentComputedStyle","_parent","styles","offsetHeight","_offsetToWindow","right","documentElement","clientWidth","_offsetToParent","borderTopWidth","borderLeftWidth","borderRightWidth","_styles","bottom","width","nodeTopValue","_limits","start","end","borderBottomWidth","parentPosition","_recalcPosition","clone","_clone","height","padding","border","borderSpacing","fontSize","insertBefore","stickyMode","Math","abs","removeChild","index","splice","Stickyfill","forceSticky","init","refreshAll","addOne","nodeList","addedStickies","forEach","removeOne","removeAll","checkScroll","pageXOffset","fastCheckTimer","startFastCheckTimer","setInterval","_fastCheck","stopFastCheckTimer","clearInterval","docHiddenKey","visibilityChangeEventName","module","exports","elements","require"],"mappings":"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A;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACzGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,uBAAuB,kBAAkB;AACzC;AACA,uBAAuB,mBAAmB;AAC1C;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,0BAA0B;AACrC;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,mBAAmB;AAC/B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,UAAU;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,CAAC;;;;;;;UCr/BD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,cAAc,0BAA0B,EAAE;WAC1C,cAAc,eAAe;WAC7B,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,6CAA6C,wDAAwD,E;;;;;WCArG;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;ACNAC,mBAAO,CAAC,4FAAD,CAAP;;AACAA,mBAAO,CAAC,4CAAD,CAAP;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["const userAgent = window.navigator.userAgent.toLowerCase();\nconsole.log(userAgent);\nconst tag = document.getElementsByTagName('body')[0];\n\nif (userAgent.indexOf('msie') != -1 || userAgent.indexOf('trident') != -1) {\n\ttag.classList.add('br_ie');\n} else if (userAgent.indexOf('edge') != -1) {\n\ttag.classList.add('br_edge');\n} else if (userAgent.indexOf('chrome') != -1) {\n\ttag.classList.add('br_chrome');\n} else if (userAgent.indexOf('safari') != -1) {\n\ttag.classList.add('br_safari');\n} else if (userAgent.indexOf('firefox') != -1) {\n\ttag.classList.add('br_firefox');\n} else {\n\ttag.classList.add('br_other');\n}\n","window.addEventListener('load', function () {\n\tdeSVG('.rep_svg', true);\n});\n","// スクロールトップボタン\nlet el = document.getElementById('btn-gotop');\nconst header = document.getElementById('header');\n\nwindow.addEventListener('scroll', () => {\n\tif (window.pageYOffset > 130) {\n\t\t//スクロールしているとき\n\t\tel.setAttribute('class', 'el_btnGoTop st_btnFadeIn'); //フェードインクラス追加\n\t\theader.setAttribute('class', 'st_isClosed'); //ヘッダクラス追加\n\t} else {\n\t\t//スクロールして上にいるとき\n\t\tel.setAttribute('class', 'el_btnGoTop st_btnFadeOut'); //フェードアウトクラス追加\n\t\theader.classList.remove('st_isClosed'); //ヘッダクラス削除\n\t}\n});\n\nconst gotop = () => {\n\twindow.scrollTo({\n\t\ttop: 0,\n\t\tbehavior: 'smooth',\n\t});\n};\nwindow.gotop = gotop;\n","function headerNav() {\n\tconst nav_btn = document.getElementById('btn-header-menu');\n\tconst nav_list = document.getElementById('header-nav');\n\tnav_btn.addEventListener('click', function () {\n\t\t//ボタン判定\n\t\tif (nav_btn.getAttribute('aria-pressed') == 'true') {\n\t\t\t//trueのときにクリックされたらfalseに書き換え\n\t\t\tnav_btn.setAttribute('aria-pressed', false);\n\t\t\tnav_list.setAttribute('aria-hidden', true);\n\t\t\tnav_list.setAttribute('class', 'is-close nav-wrapper');\n\t\t} else if (nav_btn.getAttribute('aria-pressed') == 'false') {\n\t\t\t//falseならtrueに\n\t\t\tnav_btn.setAttribute('aria-pressed', true);\n\t\t\tnav_list.setAttribute('aria-hidden', false);\n\t\t\tnav_list.setAttribute('class', 'is-open nav-wrapper');\n\t\t} else {\n\t\t}\n\t});\n}\n\nif (document.readyState !== 'loading') {\n\theaderNav();\n} else {\n\tdocument.addEventListener('DOMContentLoaded', headerNav, false);\n}\n","const menu = document.querySelectorAll('.click-open');\n\nfunction toggle() {\n\tconst content = this.nextElementSibling;\n\tthis.classList.toggle('active');\n\tcontent.classList.toggle('open');\n}\n\nfor (let i = 0; i < menu.length; i++) {\n\tmenu[i].addEventListener('click', toggle);\n}\n","document.addEventListener('touchstart', function () {}, {\n\tpassive: true,\n});\n","'use strict';\n\n/*\n * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\n *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\n *    of the polyfill, but the API will remain functional to avoid breaking things.\n */\nlet seppuku = false;\n\nconst isWindowDefined = typeof window !== 'undefined';\n\n// The polyfill can’t function properly without `window` or `window.getComputedStyle`.\nif (!isWindowDefined || !window.getComputedStyle) seppuku = true;\n// Dont’t get in a way if the browser supports `position: sticky` natively.\nelse {\n\tconst testNode = document.createElement('div');\n\n\tif (\n\t\t['', '-webkit-', '-moz-', '-ms-'].some((prefix) => {\n\t\t\ttry {\n\t\t\t\ttestNode.style.position = prefix + 'sticky';\n\t\t\t} catch (e) {}\n\n\t\t\treturn testNode.style.position != '';\n\t\t})\n\t)\n\t\tseppuku = true;\n}\n\n/*\n * 2. “Global” vars used across the polyfill\n */\nlet isInitialized = false;\n\n// Check if Shadow Root constructor exists to make further checks simpler\nconst shadowRootExists = typeof ShadowRoot !== 'undefined';\n\n// Last saved scroll position\nconst scroll = {\n\ttop: null,\n\tleft: null,\n};\n\n// Array of created Sticky instances\nconst stickies = [];\n\n/*\n * 3. Utility functions\n */\nfunction extend(targetObj, sourceObject) {\n\tfor (var key in sourceObject) {\n\t\tif (sourceObject.hasOwnProperty(key)) {\n\t\t\ttargetObj[key] = sourceObject[key];\n\t\t}\n\t}\n}\n\nfunction parseNumeric(val) {\n\treturn parseFloat(val) || 0;\n}\n\nfunction getDocOffsetTop(node) {\n\tlet docOffsetTop = 0;\n\n\twhile (node) {\n\t\tdocOffsetTop += node.offsetTop;\n\t\tnode = node.offsetParent;\n\t}\n\n\treturn docOffsetTop;\n}\n\n/*\n * 4. Sticky class\n */\nclass Sticky {\n\tconstructor(node) {\n\t\tif (!(node instanceof HTMLElement))\n\t\t\tthrow new Error('First argument must be HTMLElement');\n\t\tif (stickies.some((sticky) => sticky._node === node))\n\t\t\tthrow new Error('Stickyfill is already applied to this node');\n\n\t\tthis._node = node;\n\t\tthis._stickyMode = null;\n\t\tthis._active = false;\n\n\t\tstickies.push(this);\n\n\t\tthis.refresh();\n\t}\n\n\trefresh() {\n\t\tif (seppuku || this._removed) return;\n\t\tif (this._active) this._deactivate();\n\n\t\tconst node = this._node;\n\n\t\t/*\n\t\t * 1. Save node computed props\n\t\t */\n\t\tconst nodeComputedStyle = getComputedStyle(node);\n\t\tconst nodeComputedProps = {\n\t\t\tposition: nodeComputedStyle.position,\n\t\t\ttop: nodeComputedStyle.top,\n\t\t\tdisplay: nodeComputedStyle.display,\n\t\t\tmarginTop: nodeComputedStyle.marginTop,\n\t\t\tmarginBottom: nodeComputedStyle.marginBottom,\n\t\t\tmarginLeft: nodeComputedStyle.marginLeft,\n\t\t\tmarginRight: nodeComputedStyle.marginRight,\n\t\t\tcssFloat: nodeComputedStyle.cssFloat,\n\t\t};\n\n\t\t/*\n\t\t * 2. Check if the node can be activated\n\t\t */\n\t\tif (\n\t\t\tisNaN(parseFloat(nodeComputedProps.top)) ||\n\t\t\tnodeComputedProps.display == 'table-cell' ||\n\t\t\tnodeComputedProps.display == 'none'\n\t\t)\n\t\t\treturn;\n\n\t\tthis._active = true;\n\n\t\t/*\n\t\t * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,\n\t\t *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node\n\t\t *    is in it’s initial position when we gather its params.\n\t\t */\n\t\tconst originalPosition = node.style.position;\n\t\tif (\n\t\t\tnodeComputedStyle.position == 'sticky' ||\n\t\t\tnodeComputedStyle.position == '-webkit-sticky'\n\t\t)\n\t\t\tnode.style.position = 'static';\n\n\t\t/*\n\t\t * 4. Get necessary node parameters\n\t\t */\n\t\tconst referenceNode = node.parentNode;\n\t\tconst parentNode =\n\t\t\tshadowRootExists && referenceNode instanceof ShadowRoot\n\t\t\t\t? referenceNode.host\n\t\t\t\t: referenceNode;\n\t\tconst nodeWinOffset = node.getBoundingClientRect();\n\t\tconst parentWinOffset = parentNode.getBoundingClientRect();\n\t\tconst parentComputedStyle = getComputedStyle(parentNode);\n\n\t\tthis._parent = {\n\t\t\tnode: parentNode,\n\t\t\tstyles: {\n\t\t\t\tposition: parentNode.style.position,\n\t\t\t},\n\t\t\toffsetHeight: parentNode.offsetHeight,\n\t\t};\n\t\tthis._offsetToWindow = {\n\t\t\tleft: nodeWinOffset.left,\n\t\t\tright: document.documentElement.clientWidth - nodeWinOffset.right,\n\t\t};\n\t\tthis._offsetToParent = {\n\t\t\ttop:\n\t\t\t\tnodeWinOffset.top -\n\t\t\t\tparentWinOffset.top -\n\t\t\t\tparseNumeric(parentComputedStyle.borderTopWidth),\n\t\t\tleft:\n\t\t\t\tnodeWinOffset.left -\n\t\t\t\tparentWinOffset.left -\n\t\t\t\tparseNumeric(parentComputedStyle.borderLeftWidth),\n\t\t\tright:\n\t\t\t\t-nodeWinOffset.right +\n\t\t\t\tparentWinOffset.right -\n\t\t\t\tparseNumeric(parentComputedStyle.borderRightWidth),\n\t\t};\n\t\tthis._styles = {\n\t\t\tposition: originalPosition,\n\t\t\ttop: node.style.top,\n\t\t\tbottom: node.style.bottom,\n\t\t\tleft: node.style.left,\n\t\t\tright: node.style.right,\n\t\t\twidth: node.style.width,\n\t\t\tmarginTop: node.style.marginTop,\n\t\t\tmarginLeft: node.style.marginLeft,\n\t\t\tmarginRight: node.style.marginRight,\n\t\t};\n\n\t\tconst nodeTopValue = parseNumeric(nodeComputedProps.top);\n\t\tthis._limits = {\n\t\t\tstart: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\n\t\t\tend:\n\t\t\t\tparentWinOffset.top +\n\t\t\t\twindow.pageYOffset +\n\t\t\t\tparentNode.offsetHeight -\n\t\t\t\tparseNumeric(parentComputedStyle.borderBottomWidth) -\n\t\t\t\tnode.offsetHeight -\n\t\t\t\tnodeTopValue -\n\t\t\t\tparseNumeric(nodeComputedProps.marginBottom),\n\t\t};\n\n\t\t/*\n\t\t * 5. Ensure that the node will be positioned relatively to the parent node\n\t\t */\n\t\tconst parentPosition = parentComputedStyle.position;\n\n\t\tif (parentPosition != 'absolute' && parentPosition != 'relative') {\n\t\t\tparentNode.style.position = 'relative';\n\t\t}\n\n\t\t/*\n\t\t * 6. Recalc node position.\n\t\t *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\n\t\t */\n\t\tthis._recalcPosition();\n\n\t\t/*\n\t\t * 7. Create a clone\n\t\t */\n\t\tconst clone = (this._clone = {});\n\t\tclone.node = document.createElement('div');\n\n\t\t// Apply styles to the clone\n\t\textend(clone.node.style, {\n\t\t\twidth: nodeWinOffset.right - nodeWinOffset.left + 'px',\n\t\t\theight: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\n\t\t\tmarginTop: nodeComputedProps.marginTop,\n\t\t\tmarginBottom: nodeComputedProps.marginBottom,\n\t\t\tmarginLeft: nodeComputedProps.marginLeft,\n\t\t\tmarginRight: nodeComputedProps.marginRight,\n\t\t\tcssFloat: nodeComputedProps.cssFloat,\n\t\t\tpadding: 0,\n\t\t\tborder: 0,\n\t\t\tborderSpacing: 0,\n\t\t\tfontSize: '1em',\n\t\t\tposition: 'static',\n\t\t});\n\n\t\treferenceNode.insertBefore(clone.node, node);\n\t\tclone.docOffsetTop = getDocOffsetTop(clone.node);\n\t}\n\n\t_recalcPosition() {\n\t\tif (!this._active || this._removed) return;\n\n\t\tconst stickyMode =\n\t\t\tscroll.top <= this._limits.start\n\t\t\t\t? 'start'\n\t\t\t\t: scroll.top >= this._limits.end\n\t\t\t\t? 'end'\n\t\t\t\t: 'middle';\n\n\t\tif (this._stickyMode == stickyMode) return;\n\n\t\tswitch (stickyMode) {\n\t\t\tcase 'start':\n\t\t\t\textend(this._node.style, {\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\tleft: this._offsetToParent.left + 'px',\n\t\t\t\t\tright: this._offsetToParent.right + 'px',\n\t\t\t\t\ttop: this._offsetToParent.top + 'px',\n\t\t\t\t\tbottom: 'auto',\n\t\t\t\t\twidth: 'auto',\n\t\t\t\t\tmarginLeft: 0,\n\t\t\t\t\tmarginRight: 0,\n\t\t\t\t\tmarginTop: 0,\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'middle':\n\t\t\t\textend(this._node.style, {\n\t\t\t\t\tposition: 'fixed',\n\t\t\t\t\tleft: this._offsetToWindow.left + 'px',\n\t\t\t\t\tright: this._offsetToWindow.right + 'px',\n\t\t\t\t\ttop: this._styles.top,\n\t\t\t\t\tbottom: 'auto',\n\t\t\t\t\twidth: 'auto',\n\t\t\t\t\tmarginLeft: 0,\n\t\t\t\t\tmarginRight: 0,\n\t\t\t\t\tmarginTop: 0,\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\textend(this._node.style, {\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\tleft: this._offsetToParent.left + 'px',\n\t\t\t\t\tright: this._offsetToParent.right + 'px',\n\t\t\t\t\ttop: 'auto',\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\twidth: 'auto',\n\t\t\t\t\tmarginLeft: 0,\n\t\t\t\t\tmarginRight: 0,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis._stickyMode = stickyMode;\n\t}\n\n\t_fastCheck() {\n\t\tif (!this._active || this._removed) return;\n\n\t\tif (\n\t\t\tMath.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) >\n\t\t\t\t1 ||\n\t\t\tMath.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1\n\t\t)\n\t\t\tthis.refresh();\n\t}\n\n\t_deactivate() {\n\t\tif (!this._active || this._removed) return;\n\n\t\tthis._clone.node.parentNode.removeChild(this._clone.node);\n\t\tdelete this._clone;\n\n\t\textend(this._node.style, this._styles);\n\t\tdelete this._styles;\n\n\t\t// Check whether element’s parent node is used by other stickies.\n\t\t// If not, restore parent node’s styles.\n\t\tif (\n\t\t\t!stickies.some(\n\t\t\t\t(sticky) =>\n\t\t\t\t\tsticky !== this &&\n\t\t\t\t\tsticky._parent &&\n\t\t\t\t\tsticky._parent.node === this._parent.node\n\t\t\t)\n\t\t) {\n\t\t\textend(this._parent.node.style, this._parent.styles);\n\t\t}\n\t\tdelete this._parent;\n\n\t\tthis._stickyMode = null;\n\t\tthis._active = false;\n\n\t\tdelete this._offsetToWindow;\n\t\tdelete this._offsetToParent;\n\t\tdelete this._limits;\n\t}\n\n\tremove() {\n\t\tthis._deactivate();\n\n\t\tstickies.some((sticky, index) => {\n\t\t\tif (sticky._node === this._node) {\n\t\t\t\tstickies.splice(index, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tthis._removed = true;\n\t}\n}\n\n/*\n * 5. Stickyfill API\n */\nconst Stickyfill = {\n\tstickies,\n\tSticky,\n\n\tforceSticky() {\n\t\tseppuku = false;\n\t\tinit();\n\n\t\tthis.refreshAll();\n\t},\n\n\taddOne(node) {\n\t\t// Check whether it’s a node\n\t\tif (!(node instanceof HTMLElement)) {\n\t\t\t// Maybe it’s a node list of some sort?\n\t\t\t// Take first node from the list then\n\t\t\tif (node.length && node[0]) node = node[0];\n\t\t\telse return;\n\t\t}\n\n\t\t// Check if Stickyfill is already applied to the node\n\t\t// and return existing sticky\n\t\tfor (var i = 0; i < stickies.length; i++) {\n\t\t\tif (stickies[i]._node === node) return stickies[i];\n\t\t}\n\n\t\t// Create and return new sticky\n\t\treturn new Sticky(node);\n\t},\n\n\tadd(nodeList) {\n\t\t// If it’s a node make an array of one node\n\t\tif (nodeList instanceof HTMLElement) nodeList = [nodeList];\n\t\t// Check if the argument is an iterable of some sort\n\t\tif (!nodeList.length) return;\n\n\t\t// Add every element as a sticky and return an array of created Sticky instances\n\t\tconst addedStickies = [];\n\n\t\tfor (let i = 0; i < nodeList.length; i++) {\n\t\t\tconst node = nodeList[i];\n\n\t\t\t// If it’s not an HTMLElement – create an empty element to preserve 1-to-1\n\t\t\t// correlation with input list\n\t\t\tif (!(node instanceof HTMLElement)) {\n\t\t\t\taddedStickies.push(void 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If Stickyfill is already applied to the node\n\t\t\t// add existing sticky\n\t\t\tif (\n\t\t\t\tstickies.some((sticky) => {\n\t\t\t\t\tif (sticky._node === node) {\n\t\t\t\t\t\taddedStickies.push(sticky);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t)\n\t\t\t\tcontinue;\n\n\t\t\t// Create and add new sticky\n\t\t\taddedStickies.push(new Sticky(node));\n\t\t}\n\n\t\treturn addedStickies;\n\t},\n\n\trefreshAll() {\n\t\tstickies.forEach((sticky) => sticky.refresh());\n\t},\n\n\tremoveOne(node) {\n\t\t// Check whether it’s a node\n\t\tif (!(node instanceof HTMLElement)) {\n\t\t\t// Maybe it’s a node list of some sort?\n\t\t\t// Take first node from the list then\n\t\t\tif (node.length && node[0]) node = node[0];\n\t\t\telse return;\n\t\t}\n\n\t\t// Remove the stickies bound to the nodes in the list\n\t\tstickies.some((sticky) => {\n\t\t\tif (sticky._node === node) {\n\t\t\t\tsticky.remove();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t},\n\n\tremove(nodeList) {\n\t\t// If it’s a node make an array of one node\n\t\tif (nodeList instanceof HTMLElement) nodeList = [nodeList];\n\t\t// Check if the argument is an iterable of some sort\n\t\tif (!nodeList.length) return;\n\n\t\t// Remove the stickies bound to the nodes in the list\n\t\tfor (let i = 0; i < nodeList.length; i++) {\n\t\t\tconst node = nodeList[i];\n\n\t\t\tstickies.some((sticky) => {\n\t\t\t\tif (sticky._node === node) {\n\t\t\t\t\tsticky.remove();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\tremoveAll() {\n\t\twhile (stickies.length) stickies[0].remove();\n\t},\n};\n\n/*\n * 6. Setup events (unless the polyfill was disabled)\n */\nfunction init() {\n\tif (isInitialized) {\n\t\treturn;\n\t}\n\n\tisInitialized = true;\n\n\t// Watch for scroll position changes and trigger recalc/refresh if needed\n\tfunction checkScroll() {\n\t\tif (window.pageXOffset != scroll.left) {\n\t\t\tscroll.top = window.pageYOffset;\n\t\t\tscroll.left = window.pageXOffset;\n\n\t\t\tStickyfill.refreshAll();\n\t\t} else if (window.pageYOffset != scroll.top) {\n\t\t\tscroll.top = window.pageYOffset;\n\t\t\tscroll.left = window.pageXOffset;\n\n\t\t\t// recalc position for all stickies\n\t\t\tstickies.forEach((sticky) => sticky._recalcPosition());\n\t\t}\n\t}\n\n\tcheckScroll();\n\twindow.addEventListener('scroll', checkScroll);\n\n\t// Watch for window resizes and device orientation changes and trigger refresh\n\twindow.addEventListener('resize', Stickyfill.refreshAll);\n\twindow.addEventListener('orientationchange', Stickyfill.refreshAll);\n\n\t//Fast dirty check for layout changes every 500ms\n\tlet fastCheckTimer;\n\n\tfunction startFastCheckTimer() {\n\t\tfastCheckTimer = setInterval(function () {\n\t\t\tstickies.forEach((sticky) => sticky._fastCheck());\n\t\t}, 500);\n\t}\n\n\tfunction stopFastCheckTimer() {\n\t\tclearInterval(fastCheckTimer);\n\t}\n\n\tlet docHiddenKey;\n\tlet visibilityChangeEventName;\n\n\tif ('hidden' in document) {\n\t\tdocHiddenKey = 'hidden';\n\t\tvisibilityChangeEventName = 'visibilitychange';\n\t} else if ('webkitHidden' in document) {\n\t\tdocHiddenKey = 'webkitHidden';\n\t\tvisibilityChangeEventName = 'webkitvisibilitychange';\n\t}\n\n\tif (visibilityChangeEventName) {\n\t\tif (!document[docHiddenKey]) startFastCheckTimer();\n\n\t\tdocument.addEventListener(visibilityChangeEventName, () => {\n\t\t\tif (document[docHiddenKey]) {\n\t\t\t\tstopFastCheckTimer();\n\t\t\t} else {\n\t\t\t\tstartFastCheckTimer();\n\t\t\t}\n\t\t});\n\t} else startFastCheckTimer();\n}\n\nif (!seppuku) init();\n\n/*\n * 7. Expose Stickyfill\n */\nif (typeof module != 'undefined' && module.exports) {\n\tmodule.exports = Stickyfill;\n} else if (isWindowDefined) {\n\twindow.Stickyfill = Stickyfill;\n}\n\nvar elements = document.querySelectorAll('.sticky');\nStickyfill.add(elements);\n","(function() {\n    \"use strict\";\n\n    var desvg = function(selector, removeInlineCss) {\n        removeInlineCss = removeInlineCss || false;\n\n        var images,\n            imagesLength,\n            sortImages = {},\n\n            // load svg file\n            loadSvg = function (imgURL, replaceImages) {\n                // set up the AJAX request\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET', imgURL, true);\n\n                xhr.onload = function() {\n                    var xml,\n                        svg,\n                        paths,\n                        replaceImagesLength;\n\n                    // get the response in XML format\n                    xml = xhr.responseXML;\n                    replaceImagesLength = replaceImages.length;\n\n                    // bail if no XML\n                    if (!xml) {\n                        return;\n                    }\n\n                    // this will be the <svg />\n                    svg = xml.documentElement;\n\n                    // get all the SVG paths\n                    paths = svg.querySelectorAll('path');\n\n                    if (removeInlineCss) {\n                        // if `removeInlineCss` is true then remove the style attributes from the SVG paths\n                        for (var i = 0; i < paths.length; i++) {\n                            paths[i].removeAttribute('style');\n                        }\n                    }\n                    svg.removeAttribute('xmlns:a');\n\n                    while(replaceImagesLength--) {\n                        replaceImgWithSvg(replaceImages[replaceImagesLength], svg.cloneNode(true));\n                    }\n                };\n\n                xhr.send();\n            },\n\n            // replace the original <img /> with the new <svg />\n            replaceImgWithSvg = function (img, svg) {\n                var imgID = img.id,\n                    imgClasses = img.getAttribute('class');\n\n                if (imgID) {\n                    // re-assign the ID attribute from the <img />\n                    svg.id = imgID;\n                }\n\n                if (imgClasses) {\n                    // re-assign the class attribute from the <img />\n                    svg.setAttribute('class', imgClasses + ' replaced-svg');\n                }\n\n                img.parentNode.replaceChild(svg, img);\n            };\n\n\n\n        // grab all the elements from the document matching the passed in selector\n        images = document.querySelectorAll(selector);\n        imagesLength = images.length;\n\n        // sort images array by image url\n        while (imagesLength--) {\n            var _img = images[imagesLength],\n              _imgURL;\n\n            if (_img.getAttribute('data-src')) {\n              _imgURL = _img.getAttribute('data-src')\n            } else {\n              _imgURL = _img.getAttribute('src')\n            }\n\n            if (sortImages[_imgURL]) {\n                sortImages[_imgURL].push(_img);\n            } else {\n                sortImages[_imgURL] = [_img];\n            }\n        }\n\n        // loops over the matched urls\n        for (var key in sortImages) {\n            if (sortImages.hasOwnProperty(key)) {\n                loadSvg(key, sortImages[key]);\n            }\n        }\n\n    };\n\n    window.deSVG = desvg;\n})();\n\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function() {\n'use strict';\n\n// Exit early if we're not running in a browser.\nif (typeof window !== 'object') {\n  return;\n}\n\n// Exit early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\n  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n      'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  return;\n}\n\n/**\n * Returns the embedding frame element, if any.\n * @param {!Document} doc\n * @return {!Element}\n */\nfunction getFrameElement(doc) {\n  try {\n    return doc.defaultView && doc.defaultView.frameElement || null;\n  } catch (e) {\n    // Ignore the error.\n    return null;\n  }\n}\n\n/**\n * A local reference to the root document.\n */\nvar document = (function(startDoc) {\n  var doc = startDoc;\n  var frame = getFrameElement(doc);\n  while (frame) {\n    doc = frame.ownerDocument;\n    frame = getFrameElement(doc);\n  }\n  return doc;\n})(window.document);\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observing a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n/**\n * The signal updater for cross-origin intersection. When not null, it means\n * that the polyfill is configured to work in a cross-origin mode.\n * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nvar crossOriginUpdater = null;\n\n/**\n * The current cross-origin intersection. Only used in the cross-origin mode.\n * @type {DOMRect|ClientRect}\n */\nvar crossOriginRect = null;\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = ensureDOMRect(entry.rootBounds);\n  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);\n  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    // Round the intersection ratio to avoid floating point math issues:\n    // https://github.com/w3c/IntersectionObserver/issues/324\n    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (\n    options.root &&\n    options.root.nodeType != 1 &&\n    options.root.nodeType != 9\n  ) {\n    throw new Error('root must be a Document or Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n\n  /** @private @const {!Array<!Document>} */\n  this._monitoringDocuments = [];\n  /** @private @const {!Array<function()>} */\n  this._monitoringUnsubscribes = [];\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Sets up the polyfill in the cross-origin mode. The result is the\n * updater function that accepts two arguments: `boundingClientRect` and\n * `intersectionRect` - just as these fields would be available to the\n * parent via `IntersectionObserverEntry`. This function should be called\n * each time the iframe receives intersection information from the parent\n * window, e.g. via messaging.\n * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nIntersectionObserver._setupCrossOriginUpdater = function() {\n  if (!crossOriginUpdater) {\n    /**\n     * @param {DOMRect|ClientRect} boundingClientRect\n     * @param {DOMRect|ClientRect} intersectionRect\n     */\n    crossOriginUpdater = function(boundingClientRect, intersectionRect) {\n      if (!boundingClientRect || !intersectionRect) {\n        crossOriginRect = getEmptyRect();\n      } else {\n        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);\n      }\n      registry.forEach(function(observer) {\n        observer._checkForIntersections();\n      });\n    };\n  }\n  return crossOriginUpdater;\n};\n\n\n/**\n * Resets the cross-origin mode.\n */\nIntersectionObserver._resetCrossOriginUpdater = function() {\n  crossOriginUpdater = null;\n  crossOriginRect = null;\n};\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections(target.ownerDocument);\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n        return item.element != target;\n      });\n  this._unmonitorIntersections(target.ownerDocument);\n  if (this._observationTargets.length == 0) {\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorAllIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibility state is visible.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function(doc) {\n  var win = doc.defaultView;\n  if (!win) {\n    // Already destroyed.\n    return;\n  }\n  if (this._monitoringDocuments.indexOf(doc) != -1) {\n    // Already monitoring.\n    return;\n  }\n\n  // Private state for monitoring.\n  var callback = this._checkForIntersections;\n  var monitoringInterval = null;\n  var domObserver = null;\n\n  // If a poll interval is set, use polling instead of listening to\n  // resize and scroll events or DOM mutations.\n  if (this.POLL_INTERVAL) {\n    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);\n  } else {\n    addEvent(win, 'resize', callback, true);\n    addEvent(doc, 'scroll', callback, true);\n    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {\n      domObserver = new win.MutationObserver(callback);\n      domObserver.observe(doc, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    }\n  }\n\n  this._monitoringDocuments.push(doc);\n  this._monitoringUnsubscribes.push(function() {\n    // Get the window object again. When a friendly iframe is destroyed, it\n    // will be null.\n    var win = doc.defaultView;\n\n    if (win) {\n      if (monitoringInterval) {\n        win.clearInterval(monitoringInterval);\n      }\n      removeEvent(win, 'resize', callback, true);\n    }\n\n    removeEvent(doc, 'scroll', callback, true);\n    if (domObserver) {\n      domObserver.disconnect();\n    }\n  });\n\n  // Also monitor the parent.\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n  if (doc != rootDoc) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._monitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function(doc) {\n  var index = this._monitoringDocuments.indexOf(doc);\n  if (index == -1) {\n    return;\n  }\n\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n\n  // Check if any dependent targets are still remaining.\n  var hasDependentTargets =\n      this._observationTargets.some(function(item) {\n        var itemDoc = item.element.ownerDocument;\n        // Target is in this context.\n        if (itemDoc == doc) {\n          return true;\n        }\n        // Target is nested in this context.\n        while (itemDoc && itemDoc != rootDoc) {\n          var frame = getFrameElement(itemDoc);\n          itemDoc = frame && frame.ownerDocument;\n          if (itemDoc == doc) {\n            return true;\n          }\n        }\n        return false;\n      });\n  if (hasDependentTargets) {\n    return;\n  }\n\n  // Unsubscribe.\n  var unsubscribe = this._monitoringUnsubscribes[index];\n  this._monitoringDocuments.splice(index, 1);\n  this._monitoringUnsubscribes.splice(index, 1);\n  unsubscribe();\n\n  // Also unmonitor the parent.\n  if (doc != rootDoc) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._unmonitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorAllIntersections = function() {\n  var unsubscribes = this._monitoringUnsubscribes.slice(0);\n  this._monitoringDocuments.length = 0;\n  this._monitoringUnsubscribes.length = 0;\n  for (var i = 0; i < unsubscribes.length; i++) {\n    unsubscribes[i]();\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  if (!this.root && crossOriginUpdater && !crossOriginRect) {\n    // Cross origin monitoring, but no initial data available yet.\n    return;\n  }\n\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, targetRect, rootRect);\n\n    var rootBounds = null;\n    if (!this._rootContainsTarget(target)) {\n      rootBounds = getEmptyRect();\n    } else if (!crossOriginUpdater || this.root) {\n      rootBounds = rootRect;\n    }\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootBounds,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} targetRect The bounding rect of the target.\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, targetRect, rootRect) {\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot && parent) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return null;\n\n    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {\n      atRoot = true;\n      if (parent == this.root || parent == document) {\n        if (crossOriginUpdater && !this.root) {\n          if (!crossOriginRect ||\n              crossOriginRect.width == 0 && crossOriginRect.height == 0) {\n            // A 0-size cross-origin intersection means no-intersection.\n            parent = null;\n            parentRect = null;\n            intersectionRect = null;\n          } else {\n            parentRect = crossOriginRect;\n          }\n        } else {\n          parentRect = rootRect;\n        }\n      } else {\n        // Check if there's a frame that can be navigated to.\n        var frame = getParentNode(parent);\n        var frameRect = frame && getBoundingClientRect(frame);\n        var frameIntersect =\n            frame &&\n            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);\n        if (frameRect && frameIntersect) {\n          parent = frame;\n          parentRect = convertFromParentRect(frameRect, frameIntersect);\n        } else {\n          parent = null;\n          intersectionRect = null;\n        }\n      }\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      var doc = parent.ownerDocument;\n      if (parent != doc.body &&\n          parent != doc.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n    }\n    if (!intersectionRect) break;\n    parent = parent && getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {ClientRect} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root && !isDoc(this.root)) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var doc = isDoc(this.root) ? this.root : document;\n    var html = doc.documentElement;\n    var body = doc.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {DOMRect|ClientRect} rect The rect object to expand.\n * @return {ClientRect} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n  return (\n    containsDeep(rootDoc, target) &&\n    (!this.root || rootDoc == target.ownerDocument)\n  );\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object|?ClientRect} The intersection rect or undefined if no\n *     intersection is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  } || null;\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {ClientRect} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n\n/**\n * Ensure that the result has all of the necessary fields of the DOMRect.\n * Specifically this ensures that `x` and `y` fields are set.\n *\n * @param {?DOMRect|?ClientRect} rect\n * @return {?DOMRect}\n */\nfunction ensureDOMRect(rect) {\n  // A `DOMRect` object has `x` and `y` fields.\n  if (!rect || 'x' in rect) {\n    return rect;\n  }\n  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case\n  // for internally calculated Rect objects. For the purposes of\n  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`\n  // for these fields.\n  return {\n    top: rect.top,\n    y: rect.top,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    right: rect.right,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n\n/**\n * Inverts the intersection and bounding rect from the parent (frame) BCR to\n * the local BCR space.\n * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.\n * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.\n * @return {ClientRect} The local root bounding rect for the parent's children.\n */\nfunction convertFromParentRect(parentBoundingRect, parentIntersectionRect) {\n  var top = parentIntersectionRect.top - parentBoundingRect.top;\n  var left = parentIntersectionRect.left - parentBoundingRect.left;\n  return {\n    top: top,\n    left: left,\n    height: parentIntersectionRect.height,\n    width: parentIntersectionRect.width,\n    bottom: top + parentIntersectionRect.height,\n    right: left + parentIntersectionRect.width\n  };\n}\n\n\n/**\n * Checks to see if a parent element contains a child element (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {\n    // If this node is a document node, look for the embedding frame.\n    return getFrameElement(node);\n  }\n\n  // If the parent has element that is assigned through shadow root slot\n  if (parent && parent.assignedSlot) {\n    parent = parent.assignedSlot.parentNode\n  }\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n\n  return parent;\n}\n\n/**\n * Returns true if `node` is a Document.\n * @param {!Node} node\n * @returns {boolean}\n */\nfunction isDoc(node) {\n  return node && node.nodeType === 9;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}());\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","require('intersection-observer');\r\nrequire('desvg');\r\n\r\nimport './js/menu_openclose';\r\nimport './js/browser';\r\nimport './js/header_menu';\r\nimport './js/gotop';\r\nimport './js/onTouch';\r\nimport './js/deSVG';\r\nimport './js/stickyfill';\r\n"],"sourceRoot":""}